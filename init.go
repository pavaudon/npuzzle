package main

import (
	"errors"
	"fmt"
	"io/ioutil"
	"math"
	"math/rand"
	"strconv"
	"strings"
	"time"
)

/*
	ValidMap  si il n'y a aucun doublon dans la map
*/
func (env *MyEnv) ValidMap() bool {
	checktab := make([]bool, env.Size*env.Size)
	for i := range env.Map {
		for ii := range env.Map[i] {
			if checktab[env.Map[i][ii]] == false {
				checktab[env.Map[i][ii]] = true
			} else {
				return false
			}
		}
	}
	return true
}

/*
	ParseFile prend en parametre un fichier pour remplir la MAP
*/
func (env *MyEnv) ParseFile(file string) (err error) {
	content, err := ioutil.ReadFile(file)
	if err != nil {
		return
	}
	return env.InsertTheMap(string(content))
}

/*
	InsertTheMap insert la map dans la structure et verifie les valeurs
*/
func (env *MyEnv) InsertTheMap(myMap string) (err error) {
	env.Size = 0
	contentSplited := strings.Split(myMap, "\n")
	count := 0
	for i := range contentSplited {
		newLine := strings.TrimSpace(strings.Split(contentSplited[i], "#")[0])
		if len(newLine) == 0 {
			continue
		} else if len(newLine) == 1 && env.Size == 0 {
			env.Size, err = strconv.Atoi(newLine)
			if err != nil {
				return
			}
			err = env.initTheMap()
			if err != nil {
				return
			}
			continue
		}
		if count >= env.Size {
			return errors.New("Wrong format file (too much line)")
		}

		AllValue := ClearValue(strings.Split(newLine, " "))
		if len(AllValue) != env.Size {
			return errors.New("Wrong format file (number of value)")
		}
		for ii := range AllValue {
			val, err2 := strconv.ParseInt(AllValue[ii], 10, 8)
			if err2 != nil {
				return err2
			}
			if int(val) > env.Size*env.Size || val < 0 {
				return errors.New("Wrong values in the file")
			}
			env.Map[count][ii] = uint8(val)
		}
		count++
	}
	return
}

/*
	ClearValue nettoie (enleve les espaces) les valeurs en recursif.
*/
func ClearValue(AllValue []string) (ret []string) {
	for ii := range AllValue {
		if len(AllValue[ii]) == 0 {
			return ClearValue(append(AllValue[:ii], AllValue[ii+1:]...))
		}
	}
	return AllValue
}

/*
	initTheMap initialise la map dans la structure
*/
func (env *MyEnv) initTheMap() (err error) {
	env.Map = make([][]uint8, env.Size)
	for i := range env.Map {
		env.Map[i] = make([]uint8, env.Size)
	}
	env.MapSorted = make([][]uint8, env.Size)
	for i := range env.MapSorted {
		env.MapSorted[i] = make([]uint8, env.Size)
	}

	switch *env.Conf.SortMode {
	case 0:
		env.TraditionalSort()
	case 1:
		env.SnailSort()
	default:
		return errors.New("Unknown mode of sort")
	}
	return
}

/*
	TraditionalSort Crée une map triée (comme resultat a atteindre ou comme base pour la creation de map aleatoire)
*/
func (env *MyEnv) TraditionalSort() {
	count := uint8(1)
	for i := range env.MapSorted {
		for ii := range env.MapSorted[i] {
			if count >= uint8(env.Size*env.Size) {
				return
			}
			env.MapSorted[i][ii] = count
			count++
		}
	}
}

/*
	SnailSort Crée une map triée (comme resultat a atteindre ou comme base pour la creation de map aleatoire) [Version serptent]
*/
func (env *MyEnv) SnailSort() {
	count := uint8(1)
	i, ii := 0, 0
	limite := 1
	for int(count) < (env.Size * env.Size) {
		env.MapSorted[i][ii] = count
		if i >= limite && ii == limite-1 { //Je remonte tout a gauche
			i--
			if i == limite {
				limite++
			}
		} else if i == env.Size-limite && ii > limite-1 { // Je vais a gauche
			ii--
		} else if ii == env.Size-limite { //Je vais en bas
			i++
		} else if ii < env.Size { //Je vais a droite
			ii++
		}
		count++
	}
}

/*
	GeneratePuzzle Genere des map aleatoires
*/
func (env *MyEnv) GeneratePuzzle() (err error) {
	env.Size = int(*env.Conf.GenSize)
	if env.Size < 3 ||  env.Size > 7 {
		return errors.New("WRONG SIZE TO GENERATE")
	} 
	err = env.initTheMap()
	if err != nil {
		return
	}
	for i := range env.MapSorted {
		copy(env.Map[i], env.MapSorted[i])
	}
	rand.Seed(time.Now().UnixNano())
	if *env.Conf.Iteration == 0 {
		*env.Conf.Iteration = uint(rand.Intn((int(math.Pow(float64(env.Size), float64(env.Size)))*env.Size)-(env.Size*env.Size)) + (env.Size * env.Size))
	}
	for i := 0; i < int(*env.Conf.Iteration); i++ {
		err = env.swapEmpty()
		if err != nil {
			return
		}
	}
	fmt.Println("# Map randomly generated by the software")
	fmt.Println("# There have been", *env.Conf.Iteration, "iterations and the size is", env.Size, "x", env.Size)
	if !*env.Conf.Solvable {
		if env.Map[0][0] == 0 || env.Map[0][1] == 0 {
			env.Map[env.Size-1][env.Size-1], env.Map[env.Size-1][env.Size-2] = env.Map[env.Size-1][env.Size-2], env.Map[env.Size-1][env.Size-1]
		} else {
			env.Map[0][0], env.Map[0][1] = env.Map[0][1], env.Map[0][0]
		}
		fmt.Println("# /!\\ This map is (normaly) NOT SOLVABLE")
	} else {
		fmt.Println("# This map is SOLVABLE")
	}

	switch *env.Conf.SortMode {
	case 0:
		fmt.Println("# This map is ordered in a TRADITIONAL SORT")
	case 1:
		fmt.Println("# This map is ordered in a SNAIL SORT")
	default:
		return errors.New("Unknown mode of sort")
	}

	fmt.Println("# SOFTWARE MADE By Pascal BENOIT & Pauline VAUDON")
	fmt.Println(env.Size)
	PrintTheMap(env.Map)
	fmt.Println("#### END OF THE FILE ####")
	return
}

/*
	swapEmpty choisi dans quelle direction on bouge le 0 aleatoirement
*/
func (env *MyEnv) swapEmpty() (err error) {
	x, y, err := findPlaceOnMap(env.Map, 0)
	for {
		code := rand.Intn(4)
		switch code {
		case 0: //TO BOT
			if x < env.Size-1 {
				return env.makeAMove(x+1, y)
			}
			break
		case 1: //TO TOP
			if x > 0 {
				return env.makeAMove(x-1, y)
			}
			break
		case 2: //TO LEFT
			if y > 0 {
				return env.makeAMove(x, y-1)
			}
			break
		case 3: //TO RIGHT
			if y < env.Size-1 {
				return env.makeAMove(x, y+1)
			}
			break
		default:
			return errors.New("The random has failed")
		}
	}
}

/*
	makeAMove Bouge le 0 dans la direction qui a ete choisie
*/
func (env *MyEnv) makeAMove(x, y int) (err error) {
	zeroX, zeroY, err := findPlaceOnMap(env.Map, 0)
	if err != nil {
		return
	}
	if (zeroX-x == 0 && zeroY-y != -1 && zeroY-y != 1) || // Same colomn
		(zeroY-y == 0 && zeroX-x != -1 && zeroX-x != 1) || // Same line
		(zeroY-y != 0 && zeroX-x != 0) { // Other Move
		return errors.New("The move is too big")
	}
	val := env.Map[x][y]
	env.Map[x][y] = 0
	env.Map[zeroX][zeroY] = val
	return
}
